
"""
Templates for method. Note these are toy methods generated by LLM which
should never be used in real simulation work, these are just minimal examples to
show how loops can be constructed.
"""

import numpy as np
from scipy.sparse import coo_matrix
from benchmarks._1_coeffs_computing import compute_rimsafe_alltri
# benchmarks/_benchmark_toy_methods.py
import os

def compute_coeffs_rimsafe(msh_path,
                           out_csv=None,
                           min_pts=10,
                           theta_max_deg=35.0,
                           plane_rel=1e-3,
                           plane_abs=1e-9,
                           irls=0,
                           snap_rel=5e-6,
                           snap_abs=1e-9,
                           canonize_abc=True,
                           debug_j=False):
    from benchmarks._1_coeffs_computing import compute_rimsafe_alltri

    msh_path = str(msh_path)
    if out_csv is None:
        base = os.path.splitext(os.path.basename(msh_path))[0]
        out_csv = os.path.join(os.path.dirname(msh_path), f"{base}_COEFFS.csv")

    df, total_tris, skipped_flat = compute_rimsafe_alltri(
        msh_path, out_csv,
        min_pts=min_pts,
        theta_max_deg=theta_max_deg,
        plane_rel_tol=plane_rel,
        plane_abs_tol=plane_abs,
        irls_iters=irls,
        snap_rel=snap_rel,
        snap_abs=snap_abs,
        canonize_abc=canonize_abc,
        debug_j=debug_j,
    )
    return df, dict(total_tris=total_tris, skipped_flat=skipped_flat, out_csv=out_csv)

def compute_laplace_beltrami(points, simplices):
    n = len(points)
    I, J, V = [], [], []
    mass = np.zeros(n)

    for tri in simplices:
        i, j, k = tri
        for a, b, c in [(i, j, k), (j, k, i), (k, i, j)]:
            va, vb, vc = points[a], points[b], points[c]
            ab = vb - va
            ac = vc - va

            cross = np.cross(ab, ac)
            norm_cross = np.linalg.norm(cross)
            cot_alpha = 0 if norm_cross == 0 else np.dot(ab, ac) / norm_cross
            cot_alpha = max(cot_alpha, 0)

            I.extend([a, b])
            J.extend([b, a])
            V.extend([cot_alpha, cot_alpha])

            area = 0.5 * norm_cross
            mass[a] += area / 3
            mass[b] += area / 3
            mass[c] += area / 3

    L = coo_matrix((V, (I, J)), shape=(n, n)).tocsc()
    diag = np.array(L.sum(axis=1)).flatten()
    L.setdiag(-diag)

    lb_result = L @ points
    H_norm = 0.5 * np.linalg.norm(lb_result, axis=1) / mass
    return H_norm

def compute_area_vertex_default(points, simplices):
    n = len(points)
    local_area = np.zeros(n)
    for tri in simplices:
        i, j, k = tri
        a, b, c = points[i], points[j], points[k]
        area = 0.5 * np.linalg.norm(np.cross(b - a, c - a))
        local_area[i] += area / 3
        local_area[j] += area / 3
        local_area[k] += area / 3
    return local_area

def compute_area_triangle_default(points, simplices):
    areas = np.zeros(len(simplices))
    for idx, tri in enumerate(simplices):
        a, b, c = points[tri]
        areas[idx] = 0.5 * np.linalg.norm(np.cross(b - a, c - a))
    return areas

def compute_volume_default(points, simplices):
    vol = 0.0
    for tri in simplices:
        a, b, c = points[tri]
        centroid = (a + b + c) / 3
        cross = np.cross(b - a, c - a)
        vol += np.dot(centroid, cross) / 6
    return abs(vol)
